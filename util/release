#!/usr/bin/env bash

# shellcheck disable=2235

set -euo pipefail

export VERSION=$(grep '^version:' "$(dirname "$0")/../Meta" | cut -d' ' -f2)

case "$(uname -s)" in
  Linux*)
    OS_NAME=linux
    SED='sed -i' ;;
  Darwin*)
    OS_NAME=macos
    SED="sed -i ''" ;;
  MINGW*|MSYS*|CYGWIN*)
    OS_NAME=windows
    SED='sed -i' ;;
esac

main() (
  "do-$1"
)

# Bump version and update changelog
# Usage: make version-bump o=0.1.0 n=0.2.0
do-version-bump() (
  ([[ ${OLD_VERSION:-} ]] && [[ ${NEW_VERSION:-} ]]) ||
    die 'ERROR: Usage: make version-bump o=OLD_VERSION n=NEW_VERSION'

  echo "Bumping version from $OLD_VERSION to $NEW_VERSION..."
  export ROOT=$PWD
  export YS_RELEASE_VERSION_OLD=$OLD_VERSION
  export YS_RELEASE_VERSION_NEW=$NEW_VERSION
  ./util/version-bump

  echo
  echo 'Generating changelog entry from git history...'

  git log --oneline "$OLD_VERSION"..HEAD 2>/dev/null |
    tac |
    sed 's/^[a-f0-9]* /  - /' > release-changes.txt ||
    (echo "  - Update to version $NEW_VERSION" > release-changes.txt)

  (
    echo "- version: $NEW_VERSION"
    echo "  date:    $(date)"
    echo '  changes:'
    cat release-changes.txt
  ) > release-entry.txt
  echo ""
  echo 'Opening editor to review changelog entry...'

  ${EDITOR:-vi} release-changes.txt
  echo
  read -r -p 'Save this entry to Changes file? [Y/n] ' answer
  if [[ ${answer:-Y} =~ ^[Yy] ]]; then
    sed 's/^[a-f0-9]* /  - /' release-changes.txt \
      > release-changes-formatted.txt
    (
      echo "- version: $NEW_VERSION"
      echo "  date:    $(date)"
      echo '  changes:'
      cat release-changes-formatted.txt
      echo ""
    ) > release-entry.txt
    cat release-entry.txt Changes > Changes.new
    mv Changes.new Changes
    rm -f release-changes.txt release-changes-formatted.txt release-entry.txt
    echo 'Changelog updated!'
  else
    echo 'Changelog NOT updated. Entry saved in release-changes.txt'
  fi
)

# Check that VERSION input matches Meta file
do-check-version() (
  META_VERSION=$(grep '^version:' Meta | cut -d' ' -f2)
  [[ $META_VERSION == "$VERSION" ]] ||
    die "ERROR: VERSION=$VERSION does not match Meta file version: $META_VERSION"
  echo "Version check passed: $VERSION"
)

# Check if git tag already exists
do-check-tag() (
  if git rev-parse "$VERSION" >/dev/null 2>&1; then
    die "ERROR: Tag $VERSION already exists"
  fi
  echo "Tag $VERSION does not exist - proceeding with release"
)

# Build shared library for current platform
do-release-lib() (
  # Build the library
  make -C libyamlstar build

  # Detect architecture
  case "$(uname -m)" in
    x86_64|amd64) ARCH=x64 ;;
    aarch64|arm64) ARCH=arm64 ;;
    *) die "ERROR: Unsupported architecture $(uname -m)" ;;
  esac

  # Set platform-specific values
  if [[ $OS_NAME == linux ]]; then
    PLATFORM=linux-$ARCH
    EXT=so
    ARCHIVE_CMD='tar -cJf'
    ARCHIVE_EXT=tar.xz
  elif [[ $OS_NAME == macos ]]; then
    PLATFORM=macos-$ARCH
    EXT=dylib
    ARCHIVE_CMD='tar -cJf'
    ARCHIVE_EXT=tar.xz
  elif [[ $OS_NAME == windows ]]; then
    PLATFORM=windows-$ARCH
    EXT=dll
    ARCHIVE_CMD='zip -r'
    ARCHIVE_EXT=zip
  fi

  # Create release directory structure
  RELEASE_DIR=libyamlstar-$VERSION-$PLATFORM
  RELEASE_PATH=dist/$RELEASE_DIR

  echo "Creating release package: $RELEASE_DIR"
  rm -rf "$RELEASE_PATH"
  mkdir -p "$RELEASE_PATH"

  # Copy library files
  for f in libyamlstar/lib/libyamlstar.$EXT*; do
    cp -P "$f" "$RELEASE_PATH/"
  done

  # Fix symlinks to point to correct names
  cd "$RELEASE_PATH"
  rm -f libyamlstar.$EXT libyamlstar.$EXT.0
  ln -sf libyamlstar.$EXT.$VERSION libyamlstar.$EXT
  ln -sf libyamlstar.$EXT.$VERSION libyamlstar.$EXT.0
  cd - > /dev/null

  # Copy header files
  cp libyamlstar/lib/*.h "$RELEASE_PATH/"

  # Create installation Makefile
  cat > "$RELEASE_PATH/Makefile" <<'...'
SHELL := bash

ROOT := $(shell cd '$(abspath $(dir $(lastword $(MAKEFILE_LIST))))' && pwd -P)

YAMLSTAR_VERSION := VERSION_PLACEHOLDER

LIBYAMLSTAR := $(firstword $(wildcard libyamlstar.*))

PREFIX ?= /usr/local

install:
ifneq (,$(LIBYAMLSTAR))
	mkdir -p $(PREFIX)/lib
	cp -pP libyamlstar.EXT_PLACEHOLDER* $(PREFIX)/lib/
	mkdir -p $(PREFIX)/include/libyamlstar-$(YAMLSTAR_VERSION)
	cp -pP *.h $(PREFIX)/include/libyamlstar-$(YAMLSTAR_VERSION)/
	@echo 'Installed $(PREFIX)/lib/$(LIBYAMLSTAR) - version $(YAMLSTAR_VERSION)'
else
	$(error Weird! Nothing to install in this directory.)
endif
...

  # Replace placeholders in Makefile
  $SED "s/VERSION_PLACEHOLDER/$VERSION/g" "$RELEASE_PATH/Makefile"
  $SED "s/EXT_PLACEHOLDER/$EXT/g" "$RELEASE_PATH/Makefile"

  # Create ReadMe.md
  cat > "$RELEASE_PATH/ReadMe.md" <<'...'
# YAMLStar Shared Library

YAMLStar VERSION_PLACEHOLDER for PLATFORM_PLACEHOLDER

## Contents

- `libyamlstar.EXT_PLACEHOLDER.VERSION_PLACEHOLDER` - Versioned shared library
- `libyamlstar.EXT_PLACEHOLDER` - Symlink to versioned library
- `libyamlstar.EXT_PLACEHOLDER.0` - Symlink for API version compatibility
- `libyamlstar.h` - Main library header
- `graal_isolate.h` - GraalVM isolate header
- `Makefile` - Installation script

## Installation

### System-wide (requires sudo)

```bash
make install
```

Default installation prefix is `/usr/local`. To install elsewhere:

```bash
make install PREFIX=/opt/yamlstar
```

### Manual Installation

Copy the library and headers to your preferred location:

```bash
# Libraries
cp -P libyamlstar.EXT_PLACEHOLDER* /path/to/lib/

# Headers
mkdir -p /path/to/include/libyamlstar-VERSION_PLACEHOLDER
cp *.h /path/to/include/libyamlstar-VERSION_PLACEHOLDER/
```

## Usage

Include the header in your C/C++ code:

```c
#include <libyamlstar-VERSION_PLACEHOLDER/libyamlstar.h>
```

Link against the library:

```bash
gcc -o myapp myapp.c -lyamlstar
```

## More Information

- GitHub: https://github.com/yaml/yamlstar
- Documentation: https://yamlstar.org
...

  # Replace placeholders in ReadMe
  $SED "s/VERSION_PLACEHOLDER/$VERSION/g" "$RELEASE_PATH/ReadMe.md"
  $SED "s/PLATFORM_PLACEHOLDER/$PLATFORM/g" "$RELEASE_PATH/ReadMe.md"
  $SED "s/EXT_PLACEHOLDER/$EXT/g" "$RELEASE_PATH/ReadMe.md"

  # Create archive
  mkdir -p dist
  cd dist
  if [[ $ARCHIVE_EXT == zip ]]; then
    $ARCHIVE_CMD "$RELEASE_DIR.$ARCHIVE_EXT" "$RELEASE_DIR"
  else
    $ARCHIVE_CMD "$RELEASE_DIR.$ARCHIVE_EXT" "$RELEASE_DIR"
  fi
  cd ..

  echo "Built release artifact: dist/$RELEASE_DIR.$ARCHIVE_EXT"
  echo 'Contents:'
  if [[ $ARCHIVE_EXT == zip ]]; then
    unzip -l "dist/$RELEASE_DIR.$ARCHIVE_EXT" | tail -n +4
  else
    tar -tf "dist/$RELEASE_DIR.$ARCHIVE_EXT"
  fi
)

# Create and push git tag
do-release-tag() (
  if git rev-parse "$VERSION" >/dev/null 2>&1; then
    die "ERROR: Tag $VERSION already exists"
  fi
  git tag "$VERSION"
  git push origin "$VERSION"
  echo "Created and pushed tag $VERSION"
)

# Create GitHub release with artifacts
do-release-github() (
  if ! gh release view "$VERSION" >/dev/null 2>&1; then
    echo 'Extracting release notes from Changes file...'
    ys -e "load('Changes').find(\\(%[:version] == '$VERSION'))
           .changes.map(\\(str '- ' %))
           .join(str/lf):say" > release-notes.txt || \
      echo "Release $VERSION" > release-notes.txt
    gh release create "$VERSION" \
      --title "YAMLStar $VERSION" \
      --notes-file release-notes.txt \
      "dist/libyamlstar-$VERSION-*.tar.xz" \
      "dist/libyamlstar-$VERSION-*.zip"
    rm -f release-notes.txt
    echo "Created GitHub release $VERSION"
  else
    echo "Release $VERSION already exists"
  fi
)

# Check that GitHub release exists with all shared library assets
do-check-release() (
  git fetch --tags
  if [[ -f ~/.yamlstar-secrets.yaml ]]; then
    export GH_TOKEN=$(ys -e '.github.token:say' ~/.yamlstar-secrets.yaml)
  fi
  echo "Checking for GitHub release $VERSION..."
  gh release view "$VERSION" >/dev/null 2>&1 ||
    die "ERROR: Release $VERSION not found"
  echo 'Checking for required assets...'
  gh release view "$VERSION" --json assets --jq '.assets[].name' |
    grep -q "libyamlstar-$VERSION-linux-x64.tar.xz" ||
      die 'ERROR: Missing linux-x64 asset'
  gh release view "$VERSION" --json assets --jq '.assets[].name' |
    grep -q "libyamlstar-$VERSION-macos-arm64.tar.xz" ||
      die 'ERROR: Missing macos-arm64 asset'
  gh release view "$VERSION" --json assets --jq '.assets[].name' |
    grep -q "libyamlstar-$VERSION-windows-x64.zip" ||
      die 'ERROR: Missing windows-x64 asset'
  echo "All required assets found for $VERSION"
)

# Release Python binding to PyPI
do-release-python() (
  echo 'Publishing Python package to PyPI...'
  make dist
  if [[ -f ~/.yamlstar-secrets.yaml ]]; then
    PYPI_TOKEN=$(ys -e '.pypi.token:say' ~/.yamlstar-secrets.yaml)
    TWINE_USERNAME=__token__ \
    TWINE_PASSWORD=$PYPI_TOKEN \
      twine upload dist/*.tar.gz
  else
    die 'ERROR: ~/.yamlstar-secrets.yaml not found'
  fi
)

# Node.js - publish to npm
do-release-nodejs() (
  echo 'Publishing Node.js package to npm...'
  if [[ -f ~/.yamlstar-secrets.yaml ]]; then
    # Temporarily update version in package.json (strip -SNAPSHOT)
    $SED "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" package.json

    NPM_TOKEN=$(ys -e '.npm.token:say' ~/.yamlstar-secrets.yaml)
    echo "//registry.npmjs.org/:_authToken=$NPM_TOKEN" > .npmrc
    npm publish --access public
    rm -f .npmrc

    # Restore -SNAPSHOT version
    $SED "s/\"version\": \".*\"/\"version\": \"$VERSION-SNAPSHOT\"/" package.json
  else
    die 'ERROR: ~/.yamlstar-secrets.yaml not found'
  fi
)

# Rust - publish to crates.io
do-release-rust() (
  echo 'Publishing Rust crate to crates.io...'
  if [[ -f ~/.yamlstar-secrets.yaml ]]; then
    CARGO_TOKEN=$(ys -e '.crates.token:say' ~/.yamlstar-secrets.yaml)
    cargo publish --token "$CARGO_TOKEN"
  else
    die 'ERROR: ~/.yamlstar-secrets.yaml not found'
  fi
)

# C# - publish to NuGet
do-release-csharp() (
  echo 'Publishing C# package to NuGet...'
  if [[ -f ~/.yamlstar-secrets.yaml ]]; then
    NUGET_KEY=$(ys -e '.nuget.token:say' ~/.yamlstar-secrets.yaml)
    dotnet pack -c Release
    dotnet nuget push "bin/Release/YAMLStar.$VERSION.nupkg" \
      --api-key "$NUGET_KEY" \
      --source https://api.nuget.org/v3/index.json
  else
    die 'ERROR: ~/.yamlstar-secrets.yaml not found'
  fi
)

# Perl - publish to CPAN
do-release-perl() (
  echo 'Publishing Perl package to CPAN...'
  PAUSE_USER=$(ys -e '.pause.user:say' ~/.yamlstar-secrets.yaml)
  PAUSE_PASS=$(ys -e '.pause.pass:say' ~/.yamlstar-secrets.yaml)
  cpan-upload -u "$PAUSE_USER" -p "$PAUSE_PASS" cpan/*.tar.gz
)

# Clojure - publish to Clojars
do-release-clojure() (
  echo 'Publishing Clojure JAR to Clojars...'
  if [[ -f ~/.yamlstar-secrets.yaml ]]; then
    CLOJARS_USERNAME=$(ys -e '.clojars.user:say' ~/.yamlstar-secrets.yaml)
    CLOJARS_PASSWORD=$(ys -e '.clojars.token:say' ~/.yamlstar-secrets.yaml)
    export CLOJARS_USERNAME CLOJARS_PASSWORD
    make deploy
  else
    die 'ERROR: ~/.yamlstar-secrets.yaml not found'
  fi
)

# Java - publish to Maven Central (via Central Portal)
do-release-java() (
  echo 'Publishing Java JAR to Maven Central Portal...'
  if [[ -f ~/.yamlstar-secrets.yaml ]]; then
    GPG_KEY_ID=$(ys -e '.gpg.key-id:say' ~/.yamlstar-secrets.yaml)
    # Central Portal token (base64-encoded username:password)
    CENTRAL_TOKEN=$(ys -e '.central.token:say' ~/.yamlstar-secrets.yaml)
    export GPG_KEY_ID CENTRAL_TOKEN

    make deploy
  else
    die 'ERROR: ~/.yamlstar-secrets.yaml not found'
  fi
)

# Go - delegate to release-go script
do-release-go() (
  ../util/release-go
)

# Fortran - delegate to release-fortran script
do-release-fortran() (
  ../util/release-fortran
)

#------------------------------------------------------------------------------
# Interactive release workflow functions
#------------------------------------------------------------------------------

# List all release steps
do-release-list() {
  cat <<'EOF'
Interactive Release Workflow Steps
===================================

Run the full interactive workflow:
  make release o=OLD_VERSION n=NEW_VERSION

Or run each step individually:

  1. make release-sanity-check o=X n=Y
     - Verify old version matches Meta file
     - Verify working tree is clean
     - Validate new version format

  2. make release-version-bump o=X n=Y
     - Update version in all files (Meta, project.clj, etc.)

  3. make release-changelog o=X n=Y
     - Generate changelog from git history (X..HEAD)
     - Open in $EDITOR for review
     - Validate YAML syntax
     - Prepend to Changes file

  4. make release-commit n=Y
     - Show diff of changes
     - Prompt for commit message (editable)
     - Commit all changes

  5. make release-tag n=Y
     - Create git tag for new version
     - Handle existing tag deletion if needed

  6. make release-push n=Y
     - Push commits and tags to origin

  7. make release-build-github n=Y
     - Trigger GitHub Actions release workflow

  8. make release-bindings
     - Release all language bindings to their registries
     - (Requires prior GitHub release with shared library assets)

Example manual workflow:
  make release-sanity-check o=0.1.0 n=0.1.1
  make release-version-bump o=0.1.0 n=0.1.1
  make release-changelog o=0.1.0 n=0.1.1
  make release-commit n=0.1.1
  make release-tag n=0.1.1
  make release-push n=0.1.1
  make release-build-github n=0.1.1
  make release-bindings

Note: All steps are idempotent and can be re-run safely.
EOF
}

# Helper: Ask user for confirmation
# Usage: confirm "Question?" "Y" (default Y) or confirm "Question?" "n" (default n)
confirm() {
  local prompt=$1
  local default=${2:-Y}
  local answer

  if [[ $default =~ ^[Yy] ]]; then
    read -r -p "$prompt [Y/n]: " answer
    [[ ${answer:-Y} =~ ^[Yy] ]]
  else
    read -r -p "$prompt [y/N]: " answer
    [[ ${answer:-N} =~ ^[Yy] ]]
  fi
}

# Helper: Readline prompt with default value
readline_prompt() {
  local prompt=$1
  local default=$2
  local answer

  read -e -i "$default" -p "$prompt" answer
  echo "$answer"
}

# Helper: Validate YAML syntax
validate_yaml() {
  local file=$1

  # Try ys first, fall back to python
  if command -v ys &>/dev/null; then
    ys -e "load('$file'):say" >/dev/null 2>&1
  elif command -v python3 &>/dev/null; then
    python3 -c "import yaml; yaml.safe_load(open('$file'))" 2>/dev/null
  elif command -v python &>/dev/null; then
    python -c "import yaml; yaml.safe_load(open('$file'))" 2>/dev/null
  else
    # No validator available, assume valid
    return 0
  fi
}

# Main interactive release orchestrator
do-release() {
  ([[ ${OLD_VERSION:-} ]] && [[ ${NEW_VERSION:-} ]]) ||
    die 'ERROR: Usage: make release o=OLD_VERSION n=NEW_VERSION'

  echo "============================================================"
  echo "  YAMLStar Release Workflow"
  echo "  Version: $OLD_VERSION → $NEW_VERSION"
  echo "============================================================"
  echo
  echo "This will guide you through the release process."
  echo "Press Ctrl+C at any time to quit."
  echo

  # Step 1: Sanity checks
  echo "Step 1: Running sanity checks..."
  do-sanity-check
  echo

  # Step 2: Version bump
  if confirm "Step 2: Bump version in all files?" Y; then
    do-version-bump-files
  fi
  echo

  # Step 3: Changelog
  if confirm "Step 3: Edit changelog?" Y; then
    do-changelog
  fi
  echo

  # Step 4: Commit
  if confirm "Step 4: Commit changes?" Y; then
    do-commit
  fi
  echo

  # Step 5: Tag
  if confirm "Step 5: Create git tag?" Y; then
    do-tag
  fi
  echo

  # Step 6: Push
  if confirm "Step 6: Push to remote?" Y; then
    do-push
  fi
  echo

  # Step 7: Build on GitHub
  if confirm "Step 7: Trigger GitHub Actions build?" Y; then
    do-build-github
  fi
  echo

  # Step 8: Release bindings
  if confirm "Step 8: Release all bindings?" Y; then
    make release-bindings
  fi
  echo

  echo "============================================================"
  echo "  Release workflow complete!"
  echo "============================================================"
}

# Step 1: Sanity checks
do-sanity-check() {
  # Check that old version matches Meta file
  local meta_version
  meta_version=$(grep '^version:' Meta | cut -d' ' -f2)

  if [[ $meta_version != "$OLD_VERSION" ]]; then
    die "ERROR: Old version mismatch!" \
        "  Meta file has: $meta_version" \
        "  You specified: $OLD_VERSION" \
        "" \
        "Please use: make release o=$meta_version n=$NEW_VERSION"
  fi
  echo "✓ Old version matches Meta file: $OLD_VERSION"

  # Check working tree is clean
  if [[ -n $(git status --porcelain) ]]; then
    echo "ERROR: Working tree is not clean!"
    echo "Uncommitted changes:"
    git status --short
    die "" "Please commit or stash your changes first."
  fi
  echo "✓ Working tree is clean"

  # Validate semver bump
  if ! [[ $NEW_VERSION =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.]+)?$ ]]; then
    die "ERROR: Invalid version format: $NEW_VERSION" \
        "Expected semver format: X.Y.Z or X.Y.Z-prerelease"
  fi
  echo "✓ New version format is valid: $NEW_VERSION"

  echo "✓ All sanity checks passed"
}

# Step 2: Version bump files only (no changelog)
do-version-bump-files() {
  echo "Bumping version from $OLD_VERSION to $NEW_VERSION in all files..."

  export ROOT=$PWD
  export YS_RELEASE_VERSION_OLD=$OLD_VERSION
  export YS_RELEASE_VERSION_NEW=$NEW_VERSION

  ./util/version-bump

  echo "✓ Version bumped in all files"
  echo
  echo "Changed files:"
  git status --short
}

# Step 3: Interactive changelog editing with YAML validation
do-changelog() {
  local changes_file="Changes"
  local temp_changes="release-changes.txt"
  local entry_file="release-entry.txt"

  # Check if entry already exists for this version
  if grep -q "^- version: $NEW_VERSION" "$changes_file" 2>/dev/null; then
    echo "⚠ Changelog already has an entry for version $NEW_VERSION"
    if ! confirm "Edit it anyway?" n; then
      echo "Skipping changelog edit"
      return 0
    fi
  fi

  echo "Generating changelog from git history..."

  # Generate changes from git log
  if git log --oneline "$OLD_VERSION"..HEAD 2>/dev/null | tac | sed 's/^[a-f0-9]* /  - /' > "$temp_changes"; then
    echo "Generated $(wc -l < "$temp_changes") changes from git history"
  else
    echo "  - Update to version $NEW_VERSION" > "$temp_changes"
    echo "No git history found, using default entry"
  fi

  # Loop until valid YAML
  while true; do
    echo
    echo "Opening editor to review changelog entry..."
    ${EDITOR:-vi} "$temp_changes"

    # Build full entry
    {
      echo "- version: $NEW_VERSION"
      echo "  date:    $(date '+%a %b %d %I:%M:%S %p %Z %Y')"
      echo "  changes:"
      cat "$temp_changes"
      echo ""
    } > "$entry_file"

    # Validate YAML by prepending to Changes and checking
    cat "$entry_file" "$changes_file" > Changes.new

    echo
    echo "Validating YAML syntax..."
    if validate_yaml Changes.new; then
      echo "✓ YAML is valid"
      mv Changes.new Changes
      rm -f "$temp_changes" "$entry_file"
      echo "✓ Changelog updated"
      break
    else
      echo "✗ Invalid YAML syntax!"
      rm -f Changes.new
      echo
      read -r -p "Press Enter to re-edit or Ctrl+C to quit..."
    fi
  done
}

# Step 4: Commit with readline prompt
do-commit() {
  # Check if there are changes to commit
  if [[ -z $(git status --porcelain) ]]; then
    echo "No changes to commit"
    return 0
  fi

  echo "Changes to be committed:"
  git --no-pager diff --stat HEAD
  echo

  # Get commit message with readline (editable default)
  local default_msg="Version $NEW_VERSION"
  local commit_msg

  echo "Enter commit message (use arrow keys to edit):"
  commit_msg=$(readline_prompt "> " "$default_msg")

  if [[ -z $commit_msg ]]; then
    echo "Empty commit message, skipping commit"
    return 0
  fi

  # Commit all changes
  git add -A
  git commit -m "$commit_msg"

  echo "✓ Committed with message: $commit_msg"
}

# Step 5: Tag with deletion handling
do-tag() {
  local tag=$NEW_VERSION

  # Check if tag already exists locally
  if git rev-parse "$tag" >/dev/null 2>&1; then
    echo "⚠ Tag $tag already exists locally"
    if confirm "Delete and recreate it?" n; then
      # Delete local tag
      git tag -d "$tag"
      echo "Deleted local tag $tag"

      # Check if tag exists on remote
      if git ls-remote --tags origin | grep -q "refs/tags/$tag"; then
        if confirm "Also delete remote tag $tag?" n; then
          git push origin ":refs/tags/$tag"
          echo "Deleted remote tag $tag"
        fi
      fi
    else
      echo "Skipping tag creation"
      return 0
    fi
  fi

  # Create the tag
  git tag "$tag"
  echo "✓ Created tag $tag"
}

# Step 6: Push with confirmation
do-push() {
  local current_branch
  current_branch=$(git rev-parse --abbrev-ref HEAD)

  echo "This will push:"
  echo "  - Branch: $current_branch"
  echo "  - Tag: $NEW_VERSION"
  echo

  if confirm "Push to origin?" Y; then
    git push origin "$current_branch"
    git push origin "$NEW_VERSION"
    echo "✓ Pushed changes and tag to origin"
  else
    echo "Skipping push"
  fi
}

# Step 7: Trigger GitHub Actions build
do-build-github() {
  # Check if gh is available
  if ! command -v gh &>/dev/null; then
    echo "⚠ GitHub CLI (gh) not found"
    echo "Install it to trigger builds automatically"
    return 1
  fi

  # Get workflow name/ID
  local workflow_file=".github/workflows/release.yml"

  if [[ ! -f $workflow_file ]]; then
    echo "⚠ No release workflow found at $workflow_file"
    echo "You may need to trigger the build manually"
    return 1
  fi

  echo "Triggering GitHub Actions workflow..."

  if gh workflow run release.yml -f version="$NEW_VERSION"; then
    echo "✓ GitHub Actions workflow triggered"
    echo
    echo "Monitor progress:"
    echo "  gh run watch"
    echo "  or visit: https://github.com/$(gh repo view --json nameWithOwner -q .nameWithOwner)/actions"
  else
    echo "✗ Failed to trigger workflow"
    echo "You may need to trigger it manually on GitHub"
    return 1
  fi
}

die() {
  printf '%s\n' "$@" >&2
  exit 1
}

main "$@"
